<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Flink源码阅读笔记–DAG篇WordCount程序总览12345678910111213val env = StreamExecutionEnvironment.getExecutionEnvironmentval text = env.addSource(new RandomLocalJsonSourceFunction(1,1000))val words = text.flatMap &amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="1. Flink源码阅读笔记--DAG篇">
<meta property="og:url" content="http://yoursite.com/2019/03/09/flink-action-until-jobGraph/index.html">
<meta property="og:site_name" content="徐涛的个人主页">
<meta property="og:description" content="Flink源码阅读笔记–DAG篇WordCount程序总览12345678910111213val env = StreamExecutionEnvironment.getExecutionEnvironmentval text = env.addSource(new RandomLocalJsonSourceFunction(1,1000))val words = text.flatMap &amp;#">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/03/09/flink-action-until-jobGraph/15519530262226.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/09/flink-action-until-jobGraph/15465706985211.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/09/flink-action-until-jobGraph/15466760243164.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/09/flink-action-until-jobGraph/15468309151085.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/09/flink-action-until-jobGraph/15510811705376.jpg">
<meta property="og:updated_time" content="2019-07-17T13:50:44.893Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="1. Flink源码阅读笔记--DAG篇">
<meta name="twitter:description" content="Flink源码阅读笔记–DAG篇WordCount程序总览12345678910111213val env = StreamExecutionEnvironment.getExecutionEnvironmentval text = env.addSource(new RandomLocalJsonSourceFunction(1,1000))val words = text.flatMap &amp;#">
<meta name="twitter:image" content="http://yoursite.com/2019/03/09/flink-action-until-jobGraph/15519530262226.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/09/flink-action-until-jobGraph/">





  <title>1. Flink源码阅读笔记--DAG篇 | 徐涛的个人主页</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">徐涛的个人主页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/09/flink-action-until-jobGraph/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="徐涛">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="徐涛的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">1. Flink源码阅读笔记--DAG篇</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-09T22:55:28+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Flink源码阅读笔记–DAG篇"><a href="#Flink源码阅读笔记–DAG篇" class="headerlink" title="Flink源码阅读笔记–DAG篇"></a>Flink源码阅读笔记–DAG篇</h1><h2 id="WordCount程序总览"><a href="#WordCount程序总览" class="headerlink" title="WordCount程序总览"></a>WordCount程序总览</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val env = StreamExecutionEnvironment.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">val text = env.addSource(new RandomLocalJsonSourceFunction(1,1000))</span><br><span class="line"></span><br><span class="line">val words = text.flatMap &#123; _.toLowerCase.split(&quot;\\W+&quot;) filter &#123; _.nonEmpty &#125; &#125;</span><br><span class="line">val counts = words</span><br><span class="line">  .map &#123; (_, 1) &#125;</span><br><span class="line">  .keyBy(0)</span><br><span class="line">  .sum(1)</span><br><span class="line"></span><br><span class="line">counts.print()</span><br><span class="line"></span><br><span class="line">env.execute(&quot;Window Stream WordCount&quot;)</span><br></pre></td></tr></table></figure>
<p>可以看到一个WordCount程序大概分为5个部分</p>
<ol>
<li>构建ExecutionEnvironment</li>
<li>添加Source</li>
<li>中间做各种Transformation</li>
<li>添加Sink</li>
<li>ExecutionEnvironment.execute方法</li>
</ol>
<h2 id="构建ExecutionEnvironment"><a href="#构建ExecutionEnvironment" class="headerlink" title="构建ExecutionEnvironment"></a>构建ExecutionEnvironment</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def getExecutionEnvironment: StreamExecutionEnvironment = &#123;</span><br><span class="line">  new StreamExecutionEnvironment(JavaEnv.getExecutionEnvironment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心是StreamExecutionEnvironment.getExecutionEnvironment<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static StreamExecutionEnvironment getExecutionEnvironment() &#123;</span><br><span class="line">	if (contextEnvironmentFactory != null) &#123;</span><br><span class="line">		return contextEnvironmentFactory.createExecutionEnvironment();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// because the streaming project depends on &quot;flink-clients&quot; (and not the other way around)</span><br><span class="line">	// we currently need to intercept the data set environment and create a dependent stream env.</span><br><span class="line">	// this should be fixed once we rework the project dependencies</span><br><span class="line"></span><br><span class="line">	ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">	if (env instanceof ContextEnvironment) &#123;</span><br><span class="line">		return new StreamContextEnvironment((ContextEnvironment) env);</span><br><span class="line">	&#125; else if (env instanceof OptimizerPlanEnvironment || env instanceof PreviewPlanEnvironment) &#123;</span><br><span class="line">		return new StreamPlanEnvironment(env);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return createLocalEnvironment();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>createLocalEnvironment返回LocalStreamEnvironment。所有的都用默认，只是给ExecutionConfig设置了并行度</p>
<table>
<thead>
<tr>
<th>类</th>
<th>属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>LocalStreamEnvironment</td>
<td>Configuration</td>
</tr>
<tr>
<td>StreamExecutionEnvironment</td>
<td>ExecutionConfig</td>
</tr>
<tr>
<td>StreamExecutionEnvironment</td>
<td>CheckpointConfig</td>
</tr>
<tr>
<td>StreamExecutionEnvironment</td>
<td>transformations</td>
</tr>
<tr>
<td>StreamExecutionEnvironment</td>
<td>bufferTimeout</td>
</tr>
</tbody>
</table>
<p>TIPS:ExecutionConfig的parallelism会带到Transformation里面作为默认并行度。</p>
<h2 id="添加Source"><a href="#添加Source" class="headerlink" title="添加Source"></a>添加Source</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public &lt;OUT&gt; DataStreamSource&lt;OUT&gt; addSource(SourceFunction&lt;OUT&gt; function, String sourceName, TypeInformation&lt;OUT&gt; typeInfo) &#123;</span><br><span class="line"></span><br><span class="line">if (typeInfo == null) &#123;</span><br><span class="line">	if (function instanceof ResultTypeQueryable) &#123;</span><br><span class="line">		typeInfo = ((ResultTypeQueryable&lt;OUT&gt;) function).getProducedType();</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			typeInfo = TypeExtractor.createTypeInfo(</span><br><span class="line">					SourceFunction.class,</span><br><span class="line">					function.getClass(), 0, null, null);</span><br><span class="line">		&#125; catch (final InvalidTypesException e) &#123;</span><br><span class="line">			typeInfo = (TypeInformation&lt;OUT&gt;) new MissingTypeInfo(sourceName, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean isParallel = function instanceof ParallelSourceFunction;</span><br><span class="line"></span><br><span class="line">clean(function);</span><br><span class="line">StreamSource&lt;OUT, ?&gt; sourceOperator;</span><br><span class="line">if (function instanceof StoppableFunction) &#123;</span><br><span class="line">	sourceOperator = new StoppableStreamSource&lt;&gt;(cast2StoppableSourceFunction(function));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	sourceOperator = new StreamSource&lt;&gt;(function);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return new DataStreamSource&lt;&gt;(this, typeInfo, sourceOperator, isParallel, sourceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体：在其中先用StreamSource封装了function，然后用SourceTransformation封装了StreamSource，最后用DataStreamSource封装了SourceTransformation。</p>
<p>结果：StreamExecutionEnvironment.addSource最终返回一个DataStreamSource，这个是一个继承于DataStream的类。</p>
<p>DataStream -&gt; Transformation -&gt; Operator -&gt; Function</p>
<h2 id="flatMap算子"><a href="#flatMap算子" class="headerlink" title="flatMap算子"></a>flatMap算子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def flatMap[R: TypeInformation](fun: T =&gt; TraversableOnce[R]): DataStream[R] = &#123;</span><br><span class="line">  if (fun == null) &#123;</span><br><span class="line">    throw new NullPointerException(&quot;FlatMap function must not be null.&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  val cleanFun = clean(fun)</span><br><span class="line">  val flatMapper = new FlatMapFunction[T, R] &#123;</span><br><span class="line">    def flatMap(in: T, out: Collector[R]) &#123; cleanFun(in) foreach out.collect &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  flatMap(flatMapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; flatMap(FlatMapFunction&lt;T, R&gt; flatMapper) &#123;</span><br><span class="line"></span><br><span class="line">TypeInformation&lt;R&gt; outType = TypeExtractor.getFlatMapReturnTypes(clean(flatMapper),</span><br><span class="line">		getType(), Utils.getCallLocationName(), true);</span><br><span class="line"></span><br><span class="line">return transform(&quot;Flat Map&quot;, outType, new StreamFlatMap&lt;&gt;(clean(flatMapper)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体：</p>
<ol>
<li>先用FlatMapFunction封装自定义函数，然后调用DataStream.flatMap(FlatMapFunction)。</li>
<li>用StreamFlatMap封装FlatMapFunction；调用DataStream.transform(transformation的名字、输出类型、Operator)。</li>
<li>调用DataStream.transform</li>
</ol>
<p>结果：最终返回一个SingleOutputStreamOperator，这个是一个继承于DataStream的类。</p>
<p>TIPS: DataStream.transform做了：</p>
<ol>
<li>根据Operator生成OneInputTransformation</li>
<li>返回SingleOutputStreamOperator</li>
<li>把OneInputTransformation加入StreamExecutionEnvironment</li>
</ol>
<h2 id="map算子"><a href="#map算子" class="headerlink" title="map算子"></a>map算子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def map[R: TypeInformation](fun: T =&gt; R): DataStream[R] = &#123;</span><br><span class="line">  if (fun == null) &#123;</span><br><span class="line">    throw new NullPointerException(&quot;Map function must not be null.&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  val cleanFun = clean(fun)</span><br><span class="line">  val mapper = new MapFunction[T, R] &#123;</span><br><span class="line">    def map(in: T): R = cleanFun(in)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(mapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; map(MapFunction&lt;T, R&gt; mapper) &#123;</span><br><span class="line"></span><br><span class="line">TypeInformation&lt;R&gt; outType = TypeExtractor.getMapReturnTypes(clean(mapper), getType(),</span><br><span class="line">		Utils.getCallLocationName(), true);</span><br><span class="line"></span><br><span class="line">return transform(&quot;Map&quot;, outType, new StreamMap&lt;&gt;(clean(mapper)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>先用MapFunction封装自定义函数，然后调用DataStream.map(MapFunction）。</li>
<li>用StreamMap封装MapFunction；调用DataStream.transform(transformation的名字、输出类型、Operator)。</li>
<li>调用DataStream.transform</li>
</ol>
<p>结果：最终返回一个SingleOutputStreamOperator，这个是一个继承于DataStream的类。</p>
<h2 id="keyBy算子"><a href="#keyBy算子" class="headerlink" title="keyBy算子"></a>keyBy算子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public KeyedStream&lt;T, Tuple&gt; keyBy(int... fields) &#123;</span><br><span class="line">	if (getType() instanceof BasicArrayTypeInfo || getType() instanceof PrimitiveArrayTypeInfo) &#123;</span><br><span class="line">		return keyBy(KeySelectorUtil.getSelectorForArray(fields, getType()));</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return keyBy(new Keys.ExpressionKeys&lt;&gt;(fields, getType()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先创建Keys.ExpressionKeys封装了总的类型和key字段类型，然后调用keyBy的重载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private KeyedStream&lt;T, Tuple&gt; keyBy(Keys&lt;T&gt; keys) &#123;</span><br><span class="line">	return new KeyedStream&lt;&gt;(this, clean(KeySelectorUtil.getSelectorForKeys(keys,</span><br><span class="line">			getType(), getExecutionConfig())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个重载方法中，先调用KeySelectorUtil.getSelectorForKeys生成了ComparableKeySelector，然后调用KeyedStream构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public KeyedStream(DataStream&lt;T&gt; dataStream, KeySelector&lt;T, KEY&gt; keySelector, TypeInformation&lt;KEY&gt; keyType) &#123;</span><br><span class="line">	this(</span><br><span class="line">		dataStream,</span><br><span class="line">		new PartitionTransformation&lt;&gt;(</span><br><span class="line">			dataStream.getTransformation(),</span><br><span class="line">			new KeyGroupStreamPartitioner&lt;&gt;(keySelector, StreamGraphGenerator.DEFAULT_LOWER_BOUND_MAX_PARALLELISM)),</span><br><span class="line">		keySelector,</span><br><span class="line">		keyType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成KeyGroupStreamPartitioner(类似于Operator)封装了ComparableKeySelector，然后PartitionTransformation封装了KeyGroupStreamPartitioner，然后KeyedStream封装了PartitionTransformation。<br><img src="15519530262226.jpg" alt=""><br>KeyGroupStreamPartitioner的两个泛型来自于构造函数的第一个参数keySelector。KeyGroupStreamPartitioner&lt;T, K&gt; extends StreamPartitioner<t><br>StreamPartitioner<t> implements<br>        ChannelSelector&lt;SerializationDelegate&lt;StreamRecord<t>&gt;&gt;</t></t></t></p>
<h2 id="sum算子"><a href="#sum算子" class="headerlink" title="sum算子"></a>sum算子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private def aggregate(aggregationType: AggregationType, position: Int): DataStream[T] = &#123;</span><br><span class="line"></span><br><span class="line">  val reducer = aggregationType match &#123;</span><br><span class="line">    case AggregationType.SUM =&gt;</span><br><span class="line">      new SumAggregator(position, javaStream.getType, javaStream.getExecutionConfig)</span><br><span class="line">    case _ =&gt;</span><br><span class="line">      new ComparableAggregator(position, javaStream.getType, aggregationType, true,</span><br><span class="line">        javaStream.getExecutionConfig)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val invokable =  new StreamGroupedReduce[T](reducer,</span><br><span class="line">    getType().createSerializer(getExecutionConfig))</span><br><span class="line">   </span><br><span class="line">  new DataStream[T](javaStream.transform(&quot;aggregation&quot;, javaStream.getType(),invokable))</span><br><span class="line">    .asInstanceOf[DataStream[T]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先生成SumAggregator(类似于Function)；然后生成StreamGroupedReduce(类似于Operator)。接着调用DataStream.transform(transformation的名字、输出类型、Operator)</li>
<li>在KeyedStream.transform方法中，先调用DataStream.transform；然后设置Transformation的stateKeySelector和stateKeyType属性。</li>
</ol>
<h2 id="print算子"><a href="#print算子" class="headerlink" title="print算子"></a>print算子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public DataStreamSink&lt;T&gt; print() &#123;</span><br><span class="line">	PrintSinkFunction&lt;T&gt; printFunction = new PrintSinkFunction&lt;&gt;();</span><br><span class="line">	return addSink(printFunction).name(&quot;Print to Std. Out&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DataStreamSink&lt;T&gt; addSink(SinkFunction&lt;T&gt; sinkFunction) &#123;</span><br><span class="line"></span><br><span class="line">	// read the output type of the input Transform to coax out errors about MissingTypeInfo</span><br><span class="line">	transformation.getOutputType();</span><br><span class="line"></span><br><span class="line">	// configure the type if needed</span><br><span class="line">	if (sinkFunction instanceof InputTypeConfigurable) &#123;</span><br><span class="line">		((InputTypeConfigurable) sinkFunction).setInputType(getType(), getExecutionConfig());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	StreamSink&lt;T&gt; sinkOperator = new StreamSink&lt;&gt;(clean(sinkFunction));</span><br><span class="line"></span><br><span class="line">	DataStreamSink&lt;T&gt; sink = new DataStreamSink&lt;&gt;(this, sinkOperator);</span><br><span class="line"></span><br><span class="line">	getExecutionEnvironment().addOperator(sink.getTransformation());</span><br><span class="line">	return sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程：</p>
<ol>
<li>首先生成一个PrintSinkFunction(Function)；生成StreamSink封装PrintSinkFunction(Operator)</li>
<li>生成SinkTransformation封装StreamSink</li>
<li>DataStreamSink封装Transformation返回。</li>
<li>将Transformation加入StreamExecutionEnvironment</li>
</ol>
<p>最终形成的图如下所示：<br><img src="15465706985211.jpg" alt=""><br>StreamExecutionEnvironment.transformations中有4个transformation，分别是OneInputTransformation, OneInputTransformation, OneInputTransformation, SinkTransformation</p>
<p><strong>Stream之间的区别在于，KeyedStream多了keySelector和keyType属性</strong><br><strong>Operator之间的区别在于,StreamGroupedReduce中serializer属性。</strong><br>Function如果是RichFunction，会有StreamingRuntimeContext传入（包含Operator,RuntimeEnvironment），会有open方法<br>Operator在initializeState时，创建了StreamTaskStateInitializerImpl</p>
<h2 id="StreamExecutionEnvironment-execute"><a href="#StreamExecutionEnvironment-execute" class="headerlink" title="StreamExecutionEnvironment.execute"></a>StreamExecutionEnvironment.execute</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public JobExecutionResult execute(String jobName) throws Exception &#123;</span><br><span class="line">		// transform the streaming program into a JobGraph</span><br><span class="line">		StreamGraph streamGraph = getStreamGraph();</span><br><span class="line">		streamGraph.setJobName(jobName);</span><br><span class="line"></span><br><span class="line">		JobGraph jobGraph = streamGraph.getJobGraph();</span><br><span class="line">		jobGraph.setAllowQueuedScheduling(true);</span><br><span class="line"></span><br><span class="line">		Configuration configuration = new Configuration();</span><br><span class="line">		configuration.addAll(jobGraph.getJobConfiguration());</span><br><span class="line">		configuration.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, &quot;0&quot;);</span><br><span class="line"></span><br><span class="line">		// add (and override) the settings with what the user defined</span><br><span class="line">		configuration.addAll(this.configuration);</span><br><span class="line"></span><br><span class="line">		if (!configuration.contains(RestOptions.PORT)) &#123;</span><br><span class="line">			configuration.setInteger(RestOptions.PORT, 0);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		int numSlotsPerTaskManager = configuration.getInteger(TaskManagerOptions.NUM_TASK_SLOTS, jobGraph.getMaximumParallelism());</span><br><span class="line"></span><br><span class="line">		MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder()</span><br><span class="line">			.setConfiguration(configuration)</span><br><span class="line">			.setNumSlotsPerTaskManager(numSlotsPerTaskManager)</span><br><span class="line">			.build();</span><br><span class="line"></span><br><span class="line">		if (LOG.isInfoEnabled()) &#123;</span><br><span class="line">			LOG.info(&quot;Running job on local embedded Flink mini cluster&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		MiniCluster miniCluster = new MiniCluster(cfg);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			miniCluster.start();</span><br><span class="line">			configuration.setInteger(RestOptions.PORT, miniCluster.getRestAddress().getPort());</span><br><span class="line"></span><br><span class="line">			return miniCluster.executeJobBlocking(jobGraph);</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			transformations.clear();</span><br><span class="line">			miniCluster.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StreamExecutionEnvironment-getStreamGraph"><a href="#StreamExecutionEnvironment-getStreamGraph" class="headerlink" title="StreamExecutionEnvironment.getStreamGraph"></a>StreamExecutionEnvironment.getStreamGraph</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Internal</span><br><span class="line">public StreamGraph getStreamGraph() &#123;</span><br><span class="line">	if (transformations.size() &lt;= 0) &#123;</span><br><span class="line">		throw new IllegalStateException(&quot;No operators defined in streaming topology. Cannot execute.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return StreamGraphGenerator.generate(this, transformations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>委托StreamGraphGenerator.generate生成StreamGraph<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static StreamGraph generate(StreamExecutionEnvironment env, List&lt;StreamTransformation&lt;?&gt;&gt; transformations) &#123;</span><br><span class="line">	return new StreamGraphGenerator(env).generateInternal(transformations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>做一个StreamGraphGenerator。其中给StreamGraph实例相应初始化</li>
<li>调用其generateInternal</li>
</ol>
<table>
<thead>
<tr>
<th>StreamGraph</th>
<th>来源</th>
</tr>
</thead>
<tbody>
<tr>
<td>environment</td>
<td>environment</td>
</tr>
<tr>
<td>executionConfig</td>
<td>environment.ExecutionConfig</td>
</tr>
<tr>
<td>checkpointConfig</td>
<td>environment.CheckpointConfig</td>
</tr>
<tr>
<td>chaining</td>
<td>environment.isChainingEnabled</td>
</tr>
<tr>
<td>stateBackend</td>
<td>environment.defaultStateBackend</td>
</tr>
<tr>
<td>jobName</td>
<td>外面带入</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private StreamGraph generateInternal(List&lt;StreamTransformation&lt;?&gt;&gt; transformations) &#123;</span><br><span class="line">	for (StreamTransformation&lt;?&gt; transformation: transformations) &#123;</span><br><span class="line">		transform(transformation);</span><br><span class="line">	&#125;</span><br><span class="line">	return streamGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在generateInternal方法中，对于每个transformation，调用transform<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">private Collection&lt;Integer&gt; transform(StreamTransformation&lt;?&gt; transform) &#123;</span><br><span class="line"></span><br><span class="line">		if (alreadyTransformed.containsKey(transform)) &#123;</span><br><span class="line">			return alreadyTransformed.get(transform);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		LOG.debug(&quot;Transforming &quot; + transform);</span><br><span class="line"></span><br><span class="line">		if (transform.getMaxParallelism() &lt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">			// if the max parallelism hasn&apos;t been set, then first use the job wide max parallelism</span><br><span class="line">			// from theExecutionConfig.</span><br><span class="line">			int globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism();</span><br><span class="line">			if (globalMaxParallelismFromConfig &gt; 0) &#123;</span><br><span class="line">				transform.setMaxParallelism(globalMaxParallelismFromConfig);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// call at least once to trigger exceptions about MissingTypeInfo</span><br><span class="line">		transform.getOutputType();</span><br><span class="line"></span><br><span class="line">		Collection&lt;Integer&gt; transformedIds;</span><br><span class="line">		if (transform instanceof OneInputTransformation&lt;?, ?&gt;) &#123;</span><br><span class="line">			transformedIds = transformOneInputTransform((OneInputTransformation&lt;?, ?&gt;) transform);</span><br><span class="line">		&#125; else if (transform instanceof TwoInputTransformation&lt;?, ?, ?&gt;) &#123;</span><br><span class="line">			transformedIds = transformTwoInputTransform((TwoInputTransformation&lt;?, ?, ?&gt;) transform);</span><br><span class="line">		&#125; else if (transform instanceof SourceTransformation&lt;?&gt;) &#123;</span><br><span class="line">			transformedIds = transformSource((SourceTransformation&lt;?&gt;) transform);</span><br><span class="line">		&#125; else if (transform instanceof SinkTransformation&lt;?&gt;) &#123;</span><br><span class="line">			transformedIds = transformSink((SinkTransformation&lt;?&gt;) transform);</span><br><span class="line">		&#125; else if (transform instanceof UnionTransformation&lt;?&gt;) &#123;</span><br><span class="line">			transformedIds = transformUnion((UnionTransformation&lt;?&gt;) transform);</span><br><span class="line">		&#125; else if (transform instanceof SplitTransformation&lt;?&gt;) &#123;</span><br><span class="line">			transformedIds = transformSplit((SplitTransformation&lt;?&gt;) transform);</span><br><span class="line">		&#125; else if (transform instanceof SelectTransformation&lt;?&gt;) &#123;</span><br><span class="line">			transformedIds = transformSelect((SelectTransformation&lt;?&gt;) transform);</span><br><span class="line">		&#125; else if (transform instanceof FeedbackTransformation&lt;?&gt;) &#123;</span><br><span class="line">			transformedIds = transformFeedback((FeedbackTransformation&lt;?&gt;) transform);</span><br><span class="line">		&#125; else if (transform instanceof CoFeedbackTransformation&lt;?&gt;) &#123;</span><br><span class="line">			transformedIds = transformCoFeedback((CoFeedbackTransformation&lt;?&gt;) transform);</span><br><span class="line">		&#125; else if (transform instanceof PartitionTransformation&lt;?&gt;) &#123;</span><br><span class="line">			transformedIds = transformPartition((PartitionTransformation&lt;?&gt;) transform);</span><br><span class="line">		&#125; else if (transform instanceof SideOutputTransformation&lt;?&gt;) &#123;</span><br><span class="line">			transformedIds = transformSideOutput((SideOutputTransformation&lt;?&gt;) transform);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			throw new IllegalStateException(&quot;Unknown transformation: &quot; + transform);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// need this check because the iterate transformation adds itself before</span><br><span class="line">		// transforming the feedback edges</span><br><span class="line">		if (!alreadyTransformed.containsKey(transform)) &#123;</span><br><span class="line">			alreadyTransformed.put(transform, transformedIds);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (transform.getBufferTimeout() &gt;= 0) &#123;</span><br><span class="line">			streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout());</span><br><span class="line">		&#125;</span><br><span class="line">		if (transform.getUid() != null) &#123;</span><br><span class="line">			streamGraph.setTransformationUID(transform.getId(), transform.getUid());</span><br><span class="line">		&#125;</span><br><span class="line">		if (transform.getUserProvidedNodeHash() != null) &#123;</span><br><span class="line">			streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (transform.getMinResources() != null &amp;&amp; transform.getPreferredResources() != null) &#123;</span><br><span class="line">			streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return transformedIds;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于每种不同的transformation，调用不同的逻辑。</p>
<table>
<thead>
<tr>
<th>Transformation</th>
<th>StreamNode</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>id</td>
</tr>
<tr>
<td>slotSharingGroup计算而来</td>
<td>slotSharingGroup</td>
</tr>
<tr>
<td>coLocationGroupKey</td>
<td>coLocationGroup</td>
</tr>
<tr>
<td>operator</td>
<td>operator</td>
</tr>
<tr>
<td>name</td>
<td>operatorName</td>
</tr>
<tr>
<td></td>
<td>outputSelectors</td>
</tr>
<tr>
<td>根据不同的Transformation而不同 (SourceStreamTask,OneInputStreamTask)</td>
<td>jobVertexClass</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>input.getOutputType()</td>
<td>typeSerializerIn1</td>
</tr>
<tr>
<td>outputType</td>
<td>typeSerializerOut</td>
</tr>
<tr>
<td><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong>以上为addOperator</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>parallelism</td>
<td>parallelism</td>
</tr>
<tr>
<td>maxParallelism</td>
<td>maxParallelism</td>
</tr>
<tr>
<td>如果Transformation的stateKeySelector有</td>
<td>stateKeySerializer</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>bufferTimeout</td>
<td>bufferTimeout</td>
</tr>
<tr>
<td>uid</td>
<td>transformationUID</td>
</tr>
<tr>
<td>userProvidedNodeHash</td>
<td>userHash</td>
</tr>
<tr>
<td>minResources</td>
<td>minResources</td>
</tr>
<tr>
<td>preferredResources</td>
<td>preferredResources</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>类型</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>SourceTransformation</td>
<td>①streamGraph.addOperator</td>
</tr>
<tr>
<td>OneInputTransformation</td>
<td>①transform(input)  ②streamGraph.addOperator ③streamGraph.addEdge，在这个节点的input和它本身之间建立边</td>
</tr>
<tr>
<td>PartitionTransformation</td>
<td>①transform(input) ②对每个input新建一个虚拟ID并调用streamGraph.addVirtualPartitionNode。 在input和其对应的虚拟节点之间建立关联 (virtualId,originalId,partitioner)  ③返回virtualId</td>
</tr>
<tr>
<td>SinkTransformation</td>
<td>①transform(input) ②streamGraph.addOperator ③streamGraph.addEdge，在这个节点的input和它本身之间建立边</td>
</tr>
</tbody>
</table>
<p>在StreamGraph.addEdge中主要是调用了addEdgeInternal。在addEdgeInternal中对于一般的input节点来说，先确认Partitioner，然后再创建StreamEdge，最终把StreamEdge加入到两端的StreamNode中。对于input节点是虚拟节点的情况，重新计算背后指向的真正节点，并递归调用addEdgeInternal。</p>
<p>最终生成的StreamGraph如下图所示，总之在这一步：由StreamExecutionEnvironment的局部Transformation出发，由Transformation节点映射生成StreamNode，但有些Transformation没有进入StreamGraph；确定了边，边决定了数据路由到下游的方式。<br><img src="15466760243164.jpg" alt=""></p>
<h3 id="由StreamGraph生成JobGraph"><a href="#由StreamGraph生成JobGraph" class="headerlink" title="由StreamGraph生成JobGraph"></a>由StreamGraph生成JobGraph</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private JobGraph createJobGraph() &#123;</span><br><span class="line"></span><br><span class="line">		// make sure that all vertices start immediately</span><br><span class="line">		jobGraph.setScheduleMode(ScheduleMode.EAGER);</span><br><span class="line"></span><br><span class="line">		// Generate deterministic hashes for the nodes in order to identify them across</span><br><span class="line">		// submission iff they didn&apos;t change.</span><br><span class="line">		Map&lt;Integer, byte[]&gt; hashes = defaultStreamGraphHasher.traverseStreamGraphAndGenerateHashes(streamGraph);</span><br><span class="line"></span><br><span class="line">		// Generate legacy version hashes for backwards compatibility</span><br><span class="line">		List&lt;Map&lt;Integer, byte[]&gt;&gt; legacyHashes = new ArrayList&lt;&gt;(legacyStreamGraphHashers.size());</span><br><span class="line">		for (StreamGraphHasher hasher : legacyStreamGraphHashers) &#123;</span><br><span class="line">			legacyHashes.add(hasher.traverseStreamGraphAndGenerateHashes(streamGraph));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Map&lt;Integer, List&lt;Tuple2&lt;byte[], byte[]&gt;&gt;&gt; chainedOperatorHashes = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		setChaining(hashes, legacyHashes, chainedOperatorHashes);</span><br><span class="line"></span><br><span class="line">		setPhysicalEdges();</span><br><span class="line"></span><br><span class="line">		setSlotSharingAndCoLocation();</span><br><span class="line"></span><br><span class="line">		configureCheckpointing();</span><br><span class="line"></span><br><span class="line">		JobGraphGenerator.addUserArtifactEntries(streamGraph.getEnvironment().getCachedFiles(), jobGraph);</span><br><span class="line"></span><br><span class="line">		// set the ExecutionConfig last when it has been finalized</span><br><span class="line">		try &#123;</span><br><span class="line">			jobGraph.setExecutionConfig(streamGraph.getExecutionConfig());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IOException e) &#123;</span><br><span class="line">			throw new IllegalConfigurationException(&quot;Could not serialize the ExecutionConfig.&quot; +</span><br><span class="line">					&quot;This indicates that non-serializable types (like custom serializers) were registered&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return jobGraph;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>先生成StreamingJobGraphGenerator（在其中实例化了JobGraph），然后调用其createJobGraph方法。</p>
<table>
<thead>
<tr>
<th>JobGraph</th>
<th>来源</th>
</tr>
</thead>
<tbody>
<tr>
<td>jobId</td>
<td>new JobID()</td>
</tr>
<tr>
<td>jobName</td>
<td>StreamGraph.jobName</td>
</tr>
<tr>
<td>serializedExecutionConfig</td>
<td>StreamGraph.executionConfig</td>
</tr>
</tbody>
</table>
<p>接着在createJobGraph中，首先defaultStreamGraphHasher.traverseStreamGraphAndGenerateHashes(streamGraph);为每个StreamGraph节点生成Hash码。接着调用setChaining </p>
<h4 id="调用setChaining"><a href="#调用setChaining" class="headerlink" title="调用setChaining"></a>调用setChaining</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void setChaining(Map&lt;Integer, byte[]&gt; hashes, List&lt;Map&lt;Integer, byte[]&gt;&gt; legacyHashes, Map&lt;Integer, List&lt;Tuple2&lt;byte[], byte[]&gt;&gt;&gt; chainedOperatorHashes) &#123;</span><br><span class="line">	for (Integer sourceNodeId : streamGraph.getSourceIDs()) &#123;</span><br><span class="line">		createChain(sourceNodeId, sourceNodeId, hashes, legacyHashes, 0, chainedOperatorHashes);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在setChaining中，从每个source出发，调用createChain</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;StreamEdge&gt; createChain(</span><br><span class="line">			Integer startNodeId,</span><br><span class="line">			Integer currentNodeId,</span><br><span class="line">			Map&lt;Integer, byte[]&gt; hashes,</span><br><span class="line">			List&lt;Map&lt;Integer, byte[]&gt;&gt; legacyHashes,</span><br><span class="line">			int chainIndex,</span><br><span class="line">			Map&lt;Integer, List&lt;Tuple2&lt;byte[], byte[]&gt;&gt;&gt; chainedOperatorHashes) &#123;</span><br><span class="line"></span><br><span class="line">		if (!builtVertices.contains(startNodeId)) &#123;</span><br><span class="line"></span><br><span class="line">			List&lt;StreamEdge&gt; transitiveOutEdges = new ArrayList&lt;StreamEdge&gt;();</span><br><span class="line"></span><br><span class="line">			List&lt;StreamEdge&gt; chainableOutputs = new ArrayList&lt;StreamEdge&gt;();</span><br><span class="line">			List&lt;StreamEdge&gt; nonChainableOutputs = new ArrayList&lt;StreamEdge&gt;();</span><br><span class="line"></span><br><span class="line">			for (StreamEdge outEdge : streamGraph.getStreamNode(currentNodeId).getOutEdges()) &#123;</span><br><span class="line">				if (isChainable(outEdge, streamGraph)) &#123;</span><br><span class="line">					chainableOutputs.add(outEdge);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					nonChainableOutputs.add(outEdge);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for (StreamEdge chainable : chainableOutputs) &#123;</span><br><span class="line">				transitiveOutEdges.addAll(</span><br><span class="line">						createChain(startNodeId, chainable.getTargetId(), hashes, legacyHashes, chainIndex + 1, chainedOperatorHashes));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for (StreamEdge nonChainable : nonChainableOutputs) &#123;</span><br><span class="line">				transitiveOutEdges.add(nonChainable);</span><br><span class="line">				createChain(nonChainable.getTargetId(), nonChainable.getTargetId(), hashes, legacyHashes, 0, chainedOperatorHashes);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">//执行顺序，整体上来看，是以节点为树的深度优先遍历（函数有源参数和目的参数，中间可能会切源，目的参数随着遍历到的节点走）</span><br><span class="line">//每一个源和它后面的所有能连上的节点在子节点执行完之后都会执行下面这段代码</span><br><span class="line">//假设没有断边，那么就是一个标准的深度优先遍历</span><br><span class="line"></span><br><span class="line">			List&lt;Tuple2&lt;byte[], byte[]&gt;&gt; operatorHashes =</span><br><span class="line">				chainedOperatorHashes.computeIfAbsent(startNodeId, k -&gt; new ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">			byte[] primaryHashBytes = hashes.get(currentNodeId);</span><br><span class="line"></span><br><span class="line">			for (Map&lt;Integer, byte[]&gt; legacyHash : legacyHashes) &#123;</span><br><span class="line">				operatorHashes.add(new Tuple2&lt;&gt;(primaryHashBytes, legacyHash.get(currentNodeId)));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			chainedNames.put(currentNodeId, createChainedName(currentNodeId, chainableOutputs));</span><br><span class="line">			chainedMinResources.put(currentNodeId, createChainedMinResources(currentNodeId, chainableOutputs));</span><br><span class="line">			chainedPreferredResources.put(currentNodeId, createChainedPreferredResources(currentNodeId, chainableOutputs));</span><br><span class="line"></span><br><span class="line">			StreamConfig config = currentNodeId.equals(startNodeId)</span><br><span class="line">					? createJobVertex(startNodeId, hashes, legacyHashes, chainedOperatorHashes)</span><br><span class="line">					: new StreamConfig(new Configuration());</span><br><span class="line"></span><br><span class="line">			setVertexConfig(currentNodeId, config, chainableOutputs, nonChainableOutputs);</span><br><span class="line"></span><br><span class="line">			if (currentNodeId.equals(startNodeId)) &#123;</span><br><span class="line">//设置config属性</span><br><span class="line">				config.setChainStart();</span><br><span class="line">				config.setChainIndex(0);</span><br><span class="line">				config.setOperatorName(streamGraph.getStreamNode(currentNodeId).getOperatorName());</span><br><span class="line">				config.setOutEdgesInOrder(transitiveOutEdges);</span><br><span class="line">				config.setOutEdges(streamGraph.getStreamNode(currentNodeId).getOutEdges());</span><br><span class="line"></span><br><span class="line">				for (StreamEdge edge : transitiveOutEdges) &#123;</span><br><span class="line">					connect(startNodeId, edge);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				config.setTransitiveChainedTaskConfigs(chainedConfigs.get(startNodeId));</span><br><span class="line"></span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				Map&lt;Integer, StreamConfig&gt; chainedConfs = chainedConfigs.get(startNodeId);</span><br><span class="line"></span><br><span class="line">				if (chainedConfs == null) &#123;</span><br><span class="line">					chainedConfigs.put(startNodeId, new HashMap&lt;Integer, StreamConfig&gt;());</span><br><span class="line">				&#125;</span><br><span class="line">				config.setChainIndex(chainIndex);</span><br><span class="line">				StreamNode node = streamGraph.getStreamNode(currentNodeId);</span><br><span class="line">				config.setOperatorName(node.getOperatorName());</span><br><span class="line">				chainedConfigs.get(startNodeId).put(currentNodeId, config);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			config.setOperatorID(new OperatorID(primaryHashBytes));</span><br><span class="line"></span><br><span class="line">			if (chainableOutputs.isEmpty()) &#123;</span><br><span class="line">				config.setChainEnd();</span><br><span class="line">			&#125;</span><br><span class="line">			return transitiveOutEdges;</span><br><span class="line"></span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return new ArrayList&lt;&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>注意，生成JobVertex的原则是根据startNodeId来划分的。</p>
<p>首先创建JobVertex，对应的属性和来源分别为：</p>
<table>
<thead>
<tr>
<th>JobVertex</th>
<th>来源</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>JobVertexID(hash)</td>
</tr>
<tr>
<td>operatorIDs</td>
<td>串上的OperatorID(hash)集合</td>
</tr>
<tr>
<td>name</td>
<td>StreamNode.operatorName串</td>
</tr>
<tr>
<td>minResources</td>
<td>StreamNode.minResources串</td>
</tr>
<tr>
<td>preferredResources</td>
<td>StreamNode.preferredResources 串</td>
</tr>
<tr>
<td>invokableClassName</td>
<td>StreamNode.jobVertexClass</td>
</tr>
<tr>
<td>isStoppable</td>
<td>StreamNode.jobVertexClass推导而来</td>
</tr>
<tr>
<td>parallelism</td>
<td>StreamNode.parallelism</td>
</tr>
<tr>
<td>maxParallelism</td>
<td>StreamNode.maxParallelism</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>results</td>
<td>IDS集合</td>
</tr>
<tr>
<td>inputs</td>
<td>JobEdge集合</td>
</tr>
</tbody>
</table>
<p>接着创建StreamConfig，其值和来源分别为：</p>
<table>
<thead>
<tr>
<th>StreamConfig</th>
<th>来源</th>
</tr>
</thead>
<tbody>
<tr>
<td>setVertexID</td>
<td>StreamNode.id</td>
</tr>
<tr>
<td>setBufferTimeout</td>
<td>StreamNode.bufferTimeout</td>
</tr>
<tr>
<td>setTypeSerializerIn1</td>
<td>StreamNode.typeSerializerIn1</td>
</tr>
<tr>
<td>setTypeSerializerIn2</td>
<td>StreamNode.typeSerializerIn2</td>
</tr>
<tr>
<td>setTypeSerializerOut</td>
<td>StreamNode.typeSerializerOut</td>
</tr>
<tr>
<td>setStreamOperator</td>
<td>StreamNode.operator</td>
</tr>
<tr>
<td>setOutputSelectors</td>
<td>StreamNode.outputSelectors</td>
</tr>
<tr>
<td>setNumberOfOutputs</td>
<td>每个StreamNode的outEdges为断的数量</td>
</tr>
<tr>
<td>setNonChainedOutputs</td>
<td>每个StreamNode的outEdges为断的</td>
</tr>
<tr>
<td>setChainedOutputs</td>
<td>每个StreamNode的outEdges为非断的</td>
</tr>
<tr>
<td>setTimeCharacteristic</td>
<td>StreamGraph.Environment.timeCharacteristic</td>
</tr>
<tr>
<td>setStateBackend</td>
<td>StreamGraph.stateBackend</td>
</tr>
<tr>
<td>setStatePartitioner</td>
<td>StreamNode.statePartitioner1</td>
</tr>
<tr>
<td>setStatePartitioner</td>
<td>StreamNode.statePartitioner2</td>
</tr>
<tr>
<td>setStateKeySerializer</td>
<td>StreamNode.stateKeySerializer(这个属性决定了一个算子有没有keyedState)</td>
</tr>
<tr>
<td>setOperatorID</td>
<td>OperatorID(hash)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>setChainIndex</td>
<td>在链上的位置，从0开始</td>
</tr>
<tr>
<td>setOperatorName</td>
<td>StreamNode.operatorName</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>*setOutEdgesInOrder</td>
<td>传递断边集合StreamEdge</td>
</tr>
<tr>
<td>*setOutEdges</td>
<td>StreamNode的所有出边</td>
</tr>
<tr>
<td>*setTransitiveChainedTaskConfigs</td>
<td>链上的StreamConfig,不包括源</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>setNumberOfInputs</td>
<td>JobVertex的输入数</td>
</tr>
<tr>
<td>*setInPhysicalEdges</td>
<td>以这个节点为target的断StreamEdge集合</td>
</tr>
</tbody>
</table>
<p>connect方法核心：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobEdge = downStreamVertex.connectNewDataSetAsInput(</span><br><span class="line">					headVertex,</span><br><span class="line">					DistributionPattern.ALL_TO_ALL,</span><br><span class="line">					ResultPartitionType.PIPELINED_BOUNDED);</span><br></pre></td></tr></table></figure></p>
<p>调用下游节点JobVertex.connectNewDataSetAsInput<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public JobEdge connectNewDataSetAsInput(</span><br><span class="line">		JobVertex input,</span><br><span class="line">		DistributionPattern distPattern,</span><br><span class="line">		ResultPartitionType partitionType) &#123;</span><br><span class="line"></span><br><span class="line">	IntermediateDataSet dataSet = input.createAndAddResultDataSet(partitionType);</span><br><span class="line"></span><br><span class="line">	JobEdge edge = new JobEdge(dataSet, this, distPattern);</span><br><span class="line">	this.inputs.add(edge);</span><br><span class="line">	dataSet.addConsumer(edge);</span><br><span class="line">	return edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里是下游主动去连上游，而不同的下游在连上游时虽然上游的输出有可能只有一个，但是还是会为每个下游创建一个IDS，每个IDS的consumer只有一个。<br>调用上游的createAndAddResultDataSet创建了一个IDS。<br>然后创建JobEdge连接IDS和下游JobVertex。<br>最后给IDS增加consumer，给下游JobVertex增加input。</p>
<p>IDS上面有一个属性是partitionType（值为ResultPartitionType.PIPELINED_BOUNDED）；JobEdge上有一个属性是DistributionPattern（值为DistributionPattern.ALL_TO_ALL）</p>
<p><img src="15468309151085.jpg" alt=""></p>
<h4 id="setPhysicalEdges"><a href="#setPhysicalEdges" class="headerlink" title="setPhysicalEdges"></a>setPhysicalEdges</h4><p>为对应节点（JobVertex）的StreamConfig设置setInPhysicalEdges， List[StreamEdge]</p>
<h4 id="setSlotSharingAndCoLocation"><a href="#setSlotSharingAndCoLocation" class="headerlink" title="setSlotSharingAndCoLocation"></a>setSlotSharingAndCoLocation</h4><p>为JobVertex设置setSlotSharingGroup</p>
<h4 id="设置Checkpoint"><a href="#设置Checkpoint" class="headerlink" title="设置Checkpoint"></a>设置Checkpoint</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JobCheckpointingSettings settings = new JobCheckpointingSettings(</span><br><span class="line">			triggerVertices,</span><br><span class="line">			ackVertices,</span><br><span class="line">			commitVertices,</span><br><span class="line">			new CheckpointCoordinatorConfiguration(</span><br><span class="line">				interval,</span><br><span class="line">				cfg.getCheckpointTimeout(),</span><br><span class="line">				cfg.getMinPauseBetweenCheckpoints(),</span><br><span class="line">				cfg.getMaxConcurrentCheckpoints(),</span><br><span class="line">				retentionAfterTermination,</span><br><span class="line">				isExactlyOnce),</span><br><span class="line">			serializedStateBackend,</span><br><span class="line">			serializedHooks);</span><br></pre></td></tr></table></figure>
<p>为JobGraph设置JobCheckpointingSettings</p>
<p>总之，JobGraph在StreamGraph的基础上，形成了这样的数据结构：<br><img src="15510811705376.jpg" alt=""><br>每个StreamNode对应StreamConfig。<br>每个JobVertex的StreamConfig有属性指向链上的StreamConfig集合。<br>每个JobVertex的configuration中有属性指向出断。<br>每个JobVertex的configuration中有属性指向入断。<br>每个StreamConfig有属性指向对应StreamNode的出边。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/11/final-communication-graph/" rel="prev" title="Flink最终通信及调用流程图">
                Flink最终通信及调用流程图 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">徐涛</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Flink源码阅读笔记–DAG篇"><span class="nav-number">1.</span> <span class="nav-text">Flink源码阅读笔记–DAG篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#WordCount程序总览"><span class="nav-number">1.1.</span> <span class="nav-text">WordCount程序总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建ExecutionEnvironment"><span class="nav-number">1.2.</span> <span class="nav-text">构建ExecutionEnvironment</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加Source"><span class="nav-number">1.3.</span> <span class="nav-text">添加Source</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flatMap算子"><span class="nav-number">1.4.</span> <span class="nav-text">flatMap算子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map算子"><span class="nav-number">1.5.</span> <span class="nav-text">map算子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keyBy算子"><span class="nav-number">1.6.</span> <span class="nav-text">keyBy算子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sum算子"><span class="nav-number">1.7.</span> <span class="nav-text">sum算子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#print算子"><span class="nav-number">1.8.</span> <span class="nav-text">print算子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StreamExecutionEnvironment-execute"><span class="nav-number">1.9.</span> <span class="nav-text">StreamExecutionEnvironment.execute</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#StreamExecutionEnvironment-getStreamGraph"><span class="nav-number">1.9.1.</span> <span class="nav-text">StreamExecutionEnvironment.getStreamGraph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#由StreamGraph生成JobGraph"><span class="nav-number">1.9.2.</span> <span class="nav-text">由StreamGraph生成JobGraph</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调用setChaining"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">调用setChaining</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setPhysicalEdges"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">setPhysicalEdges</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setSlotSharingAndCoLocation"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">setSlotSharingAndCoLocation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置Checkpoint"><span class="nav-number">1.9.2.4.</span> <span class="nav-text">设置Checkpoint</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">徐涛</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
